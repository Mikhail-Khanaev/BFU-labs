#include <iostream>
#include <stdio.h> 
#include <time.h> 
#define N_Max 100000

// Вариант 2 Ханаев Михаил 
// Дана последовательность из N чисел. Посчитать количество простых чисел

void SwapSort(int mas[N_Max], int n) {
	for (int i = 0; i < n - 1; i++)
		for (int j = i + 1; j < n; j++)
			if (mas[i] > mas[j])
				std::swap(mas[i], mas[j]);
}

// Сортировка пузырьком
void BubleSort(int mas[N_Max], int n) {
	for (int i = 1; i < n; i++) {
		if (mas[i] >= mas[i - 1]) {
			continue;
		}
		int j = i - 1;

		while ((j >= 0) && (mas[j] > mas[j + 1])) {
			std::swap(mas[j], mas[j + 1]);
			j--;
		}
	}
}

bool PrimeNumber(int& n) {
	for (int i = 2; i < sqrt(n) + 1; i++) {
		if (n % i == 0) {
			return false;
		}
	}
	return true;
}



int main() {
	int counterOfPrimeNums = 0;

	srand(time(0));
	int mas[N_Max];
	for (int i = 0; i < N_Max; i++) {
		mas[i] = rand();
	}

	// Начинаю отсчёт времени именно с этого места, 
	// так как по условию лабы "ввод и вывод данных" учитывать не нужно
	clock_t start = clock();
	for (int i = 0; i < N_Max; i++) {
		if (PrimeNumber(mas[i])) {
			counterOfPrimeNums++;
			//std::cout << mas[i] << std::endl;
		}
		else {
			continue;
		}
	}
	clock_t end = clock(); // а тут соответственно заканчиваю считать
	std::cout << counterOfPrimeNums << std::endl;
	
	// Тут мои комментарии по поводу сложности алгоритма:
	// Сначала рассмотрю худший случай - все числа оказались простыми.
	// Посмотрим, сколько операций выполнит алгоритм:
	// 1. Программа сначала проверит, простое ли число
	// 2. Число оказывается простым - счётчик обновляется. 
	// Казалось бы, что операции всего две.
	// Но ведь программа должна была так же проверить все возможные делители каждого числа, начиная от 2 до корня из числа + 1. 
	// Я если честно не знаю, как это считать, так как все числа разные, а значит и количество возможных делителей разное. 
	// Но если бы я долго не думал, то сначала бы сказал, что в худшем случае программа выполнит 2*N_Max операций.
	// А в лучшем N_Max операций. Но мне кажется, что это ответы неправильные. 
	// Но так или иначе реальное время посчитать удалось
	
	double seconds = (double)(end - start) / CLOCKS_PER_SEC;
	std::cout << "Time: " << seconds << " seconds" << std::endl;

}


// Тут я просто пишу конспект по мере лекции
// Структура данных "дерево" - более бытсрый поиск, чем массив;
// Есть "формальный" язык для написания алгоритмов - псевдокод, который можно уже переписать на любой ЯП;
// Сложность работы алгоритма = примерное количество операций;
// В любом алгоритме есть понятние "лучшего", "среднего" и "худшего" случая;
// Правила для более быстрой оценки сложности алгоритмов:
// 1. Константами (например 3n, 4n, 2n) можно принебречь
// 2. Следует учитывать только ту часть, которая возрастает быстрее всего (например, если сложность 3(n^2 - n), то тройкой можно пренебречь, так как это константа,
// а "-n" это незначительная часть в сравнении с n^2. Так как при входных данных n=100 разница между n^2 - n и n^2 будет составять всего 1%)
// записывается это так: θ(n^2) (точная оценка)
// Так же есть такие понятия как "оценка сверху" и "оценка снизу";
// "Оценка сверху" это f(n) <= g(n)
// "Оценка снизу" это f(n) >= g(n) (Вроде как бесполезная вещь, но мне кажется, что эта штука может иметь смысл. Тем более раз её предумали, значит она для чего-то нужна);\
// 
// Чтобы характеризовать сложность алгоритма, используются известные функции:
// _________________________________________________________________________________________________________
// |_____________|_________________Название_______________|____1k____|____100k____|____1M____|____Время____|
// | 1. log(n)   |  логарифмическая сл. (сл. - сложность) |    ~10   |     ~16    |    ~20   | 2*10^-7 сек |
// | 2. n        |  линейная сл.                          |    1k    |    100k    |    1M    |             |
// | 3. n^2      |                                        |    1M    |   10000M   |  1 трлн  |             |
// | 4. sqrt(n)  |                                        |    32    |     316    |   1000   |             |
// | 5. n^3      |                                        |   много  |    много   |   много  |             |
// | 6. 2^n      |  полиномиальная сл.                    |          |            |          |             |
// | 7. n!       |  факториальная сл.                     |          |            |          |             |
// ---------------------------------------------------------------------------------------------------------
// Количество операций = 100 млн/сек (взято из головы)

